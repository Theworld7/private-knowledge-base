# 权衡的艺术

## 命令式和声明式
从范式上来看，视图层框架通常分为命令式和声明式。

### 命令式
命令式框架关注过程。

```javascript
$('#app') // 获取 div
	text('hello world') // 设置文本内容
	on('click', () => { alert('ok') }) // 绑定点击事件
```
自然语言描述，能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”。

### 声明式
声明式框架关注结果。

```html
<div @click="() => alert('ok')">hello world</div>
```
我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心。声明式的内部实现一定是命令式的，而暴露给用户的却更加声明式。

## 性能与可维护性的权衡
声明式代码的性能不优于命令式代码的性能。声明式代码会比命令式代码多出找出差异的性能消耗，毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式。

声明式代码的可维护性更强。声明式框架的设计目标是：在保持可维护性的同时让性能损失最小化。

### 虚拟 DOM 的性能到底如何
声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。

虚拟 DOM 理论上不可能比原生 JavaScript 操作 DOM 更高。强调理论上是因为，我们很难写出绝对优化的命令式代码，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。

原生 JavaScript 实际上指的是像 document.createElement 之类的 DOM 操作方法，并不包含 innerHTML 。

innerHTML 为了创建页面，我们需要构造一段 HTML 字符串：

```javascript
const html = `
    <div><span>...</span></div>
`
```
接着将该字符串赋值给 DOM 元素的 innerHTML 属性：`div.innerHTML = html` 。

为了渲染出页面，首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算。DOM 的运算要远比 JavaScript 层面的计算性能差。

innerHTML 创建页面的性能：HTML 字符串拼接的计算量 + innerHTML 的DOM 计算量。

虚拟 DOM 创建页面的性能：创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量。在同一个数量级，创建页面的时候，都需要新建所有 DOM 元素，没有性能差异。

更新页面时，innerHTML 重新构建 HTML 字符串，再重新设置 DOM 元素的 innerHTML 属性。等价于销毁所有旧的 DOM 元素，再全量创建新的 DOM 元素。

虚拟 DOM 需要重新创建 JavaScript 对象（虚拟 DOM 树），然后比较新旧虚拟 DOM，找到变化的元素并更新它。Diff 是 JavaScript 层面的运算，所以不会产生数量级的差异。

DOM 层面运算，虚拟 DOM 在更新页面时只会更新必要的元素，但 innerHTML 需要全量更新。这是虚拟 DOM 的优势。对于 innerHTML 来说，页面越大，就意味着更新时的性能消耗越大。

**性能从低到高 ➡️ ：**

innerHTML（模版）

- 心智负担中等
- 性能差

虚拟 DOM
- 心智负担小
- 可维护性强
- 性能不错

原生 JavaScript
- 心智负担大
- 可维护性差
- 性能高

## 运行时和编译时
纯运行时的框架，由于它没有编译的过程，因此没办法分析用户提供的内容

运行时 + 编译时，可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了。

纯编译时，由于不需要任何运行时，而是直接编译成可执行的 JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用。